# Ingredient Pairing Tool

## Overview

The **Ingredient Pairing Tool** is an intuitive web-based platform designed to assist users in finding the best ingredient pairings based on various advanced algorithms. Leveraging concepts like molecular compatibility and data-driven recommendations, this tool helps enhance culinary experiences by suggesting substitutes or complementary ingredients.

The application is highly customizable, allowing users to select their desired algorithm for pairing generation, ensuring flexibility and versatility.

## Features


- **Interactive Interface**: A responsive, visually appealing interface for user input and result display.
- **Algorithm Selection**: Choose from multiple algorithms such as Apriori, KNN, SVD, FP-Growth, Cosine Similarity, Autoencoder, and DBSCAN for pairing generation.
- **Ingredient Substitution Suggestions**: Provides a list of compatible ingredient pairings.
- **Visualization Tool**: Generate visual representations of ingredient relationships, including graphs, heatmaps, and word clouds.
- **Image Carousel**: A visual component displaying various food-related images to enhance user engagement.
- **Mobile-Friendly**: Fully responsive design, ensuring a seamless experience across devices.
- **New Multi-Ingredient Pairing Feature**: Input multiple ingredients at once to generate pairings that consider combined compatibility.

## File Structure


### 1. `index.html`

This file serves as the front-end interface of the tool, providing the following functionalities:

#### Key Features

- **Navbar**: Contains navigation links (Home, Visualization, Information) to ensure easy navigation.
- **Introductory Section**: Describes the purpose and usage of the tool.
- **Image Carousel**: Displays a carousel of ingredient and food-related images.
- **Form**: Allows users to input an ingredient and choose an algorithm for pairing generation.
- **Suggested Pairings Section**: Dynamically displays pairing suggestions returned by the backend.

#### Highlights

- **CSS Styling**: Includes styles for a professional and user-friendly interface.
- **Responsive Design**: Adapts layout for various screen sizes using media queries.
- **Dynamic Content**: Uses Jinja2 placeholders for displaying results (`{% if substitutes %}`, `{% for substitute in substitutes %}`).

### 2. Backend Application (e.g., Flask App)


The backend application processes user inputs and generates ingredient pairings. Here's how it works:

#### Input Handling:

- The form in `index.html` sends a POST request to the backend containing:
  - `ingredient`: The ingredient entered by the user.
  - `algorithm`: The selected algorithm for pairing generation.

#### Processing Logic:

- The backend receives the input and processes it using the selected algorithm.
- Algorithms like Apriori, KNN, SVD, and others analyze predefined ingredient data and determine the best matches.

#### Generating Results:

- The processed pairings are returned as a list of substitutes, formatted for display on the front-end.

#### Rendering the Response:

- The backend renders the `index.html` template, passing the substitutes to be displayed dynamically in the "Suggested Pairings" section.

### 3. `visualization.html`

This file provides an interactive platform to visualize ingredient pairings. It leverages Python libraries like NetworkX, Seaborn, and WordCloud for graph-based, heatmap-based, and word cloud representations.

#### Features

- **Navbar**: Contains links to Home, Visualization, and Information sections.
- **Form**: Users can input the number of ingredients to visualize relationships.
- **Graph Visualization**: Generates NetworkX graphs to showcase ingredient pairings.
- **Heatmap Visualization**: Displays a Seaborn heatmap for better insights into pairing relationships.
- **Word Cloud**: Generates a word cloud highlighting frequently paired ingredients.

#### Working

1. **Input Handling**:
   - Users enter the number of ingredients they want to analyze in the provided form.
2. **Data Processing**:
   - The backend generates visualizations (graph, heatmap, word cloud) using the input data.
3. **Rendering Results**:
   - The generated visualizations are returned to the `visualization.html` page and displayed dynamically.

#### HTML Highlights

- **CSS Styling**: Incorporates a visually appealing design using custom styles.
- **Responsive Design**: Ensures compatibility with both desktop and mobile screens.
- **Dynamic Visualizations**: Uses Jinja2 to render images generated by the backend (`{% if plot_image_graph %}`, etc.).

---

## How to Run the Project

### #HowToRun

1. **Clone the Repository**:

   ```bash
   git clone https://github.com/yourusername/ingredient-pairing-tool.git
   cd ingredient-pairing-tool
   ```

2. **Install Dependencies**: Ensure you have Python installed. Then, install the required libraries using pip:

   ```bash
   pip install -r requirements.txt
   ```

3. **Run the Backend Application**: Start the Flask server:

   ```bash
   python app.py
   ```

   The server will run on [http://127.0.0.1:5000](http://127.0.0.1:5000) by default.

4. **Access the Application**: Open your browser and navigate to [http://127.0.0.1:5000](http://127.0.0.1:5000).

5. **Explore Features**:

   - Use the Ingredient Pairing Tool on the main page to generate ingredient suggestions.
   - Navigate to the Visualization tab to explore graphs, heatmaps, and word clouds.
   - Experiment with the new multi-ingredient pairing feature.

## Screenshots


- **Main Interface (index.html)**
- **Visualization Page (visualization.html)**
- **Multi-Ingredient Pairing Feature**

## Future Enhancements


- **User Accounts**: Add functionality for users to save their pairing preferences.
- **Ingredient Database Expansion**: Include more ingredients and their molecular data.
- **Real-Time Data**: Enable real-time data updates from external APIs.
- **Machine Learning Models**: Integrate advanced ML models for even better pairing recommendations.
- **Multi-Language Support**: Allow users to interact with the tool in multiple languages.

## Contributing

We welcome contributions from the community! If you'd like to contribute:

1. **Fork the repository.**
2. **Create a feature branch**:
   
   ```bash
   git checkout -b feature-name
   ```

3. **Commit your changes**:
   
   ```bash
   git commit -m 'Add feature'
   ```

4. **Push to the branch**:
   
   ```bash
   git push origin feature-name
   ```

5. **Open a pull request**.

## License

This project is licensed under the MIT License. See the LICENSE file for details.

## Contact

For queries or feedback, feel free to reach out:

- **GitHub**: [bhavyanarnoli](https://github.com/bhavyanarnoli)

